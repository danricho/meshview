{% extends "base.html" %}

{% block css %}
.export-btn {
    background-color: #28a745;
    color: white;
    border: none;
}

.export-btn:hover {
    background-color: #218838;
}

.clear-btn {
    background-color: #dc3545;
    color: white;
    border: none;
}

.clear-btn:hover {
    background-color: #c82333;
}

.sort-icon { margin-left: 0.25rem; }

.count-container {
    font-weight: bold;
    color: white;
}

td.nowrap {
  overflow: hidden;
  text-overflow: ellipsis;
}


{% endblock %}

{% block body %}

<div class="filter-container container">
    <div role="group">
        <input type="text" id="search-box" class="search-box" placeholder="Search by name or ID..." />
        
        {% if site_config.get("site", {}).get("search_term", False) %}
        <script>
          function find_mine(){
            const element = document.querySelector('#search-box');
            const event = new KeyboardEvent('input');
            element.value = '{{site_config.get("site", {}).get("search_term", False)}}';
            element.dispatchEvent(event);
            return false;
          }
        </script>
        <button onclick="find_mine()">{{site_config.get("site", {}).get("search_button", False)}}</button>
        {% endif %}

        <select id="role-filter">
            <option value="">All Roles</option>
        </select>

        <select id="channel-filter" class="hide-lt-md">
            <option value="">All Channels</option>
        </select>

        <select id="hw-filter" class="hide-lt-md">
            <option value="">All HW Models</option>
        </select>

        <select id="firmware-filter" class="hide"><option value="">All Firmware</option></select>

        <button class="clear-btn" id="clear-btn">Clear</button>
        
    </div>
</div>

<div class="count-container container" style="margin-bottom: calc(var(--pico-spacing));">Showing <span id="node-count">0</span> nodes</div>

<div id="node-list" class="container">
    <table>
        <thead>
            <tr>
                <th>Short<span class="sort-icon">▲</span></th>
                <th>Long Name<span class="sort-icon"></span></th>
                <th class="hide">HW Model<span class="sort-icon"></span></th>
                <th class="hide">Firmware<span class="sort-icon"></span></th>
                <th class="hide-lt-md">Role<span class="sort-icon"></span></th>
                <th class="hide-lt-xl">Last Position<span class="sort-icon"></span></th>
                <th class="hide">Channel<span class="sort-icon"></span></th>
                <th>Updated<span class="sort-icon"></span></th>
            </tr>
        </thead>
        <tbody id="node-table-body">
            <tr><td colspan="9" style="text-align:center; color:white;">Loading nodes...</td></tr>
        </tbody>
    </table>
    
    <button class="export-btn hide-lt-md" id="export-btn">To CSV</button>
</div>

<script>
let allNodes = [];
let sortColumn = "short_name"; // default sorted column
let sortAsc = true; // default ascending

// Declare headers and keyMap BEFORE any function that uses them
const headers = document.querySelectorAll("thead th");
const keyMap = ["short_name","long_name","hw_model","firmware","role","last_pos","channel","last_update"];

document.addEventListener("DOMContentLoaded", async function() {
    const tbody = document.getElementById("node-table-body");
    const roleFilter = document.getElementById("role-filter");
    const channelFilter = document.getElementById("channel-filter");
    const hwFilter = document.getElementById("hw-filter");
    const firmwareFilter = document.getElementById("firmware-filter");
    const searchBox = document.getElementById("search-box");
    const countSpan = document.getElementById("node-count");
    const exportBtn = document.getElementById("export-btn");
    const clearBtn = document.getElementById("clear-btn");

    try {
        const response = await fetch("/api/nodes?days_active=3");
        if (!response.ok) throw new Error("Failed to fetch nodes");
        const data = await response.json();
        allNodes = data.nodes;
        populateFilters(allNodes);
        renderTable(allNodes);
        updateSortIcons();
    } catch (err) {
        tbody.innerHTML = `<tr><td colspan="9" style="text-align:center; color:red;">Error loading nodes: ${err.message}</td></tr>`;
    }

    roleFilter.addEventListener("change", applyFilters);
    channelFilter.addEventListener("change", applyFilters);
    hwFilter.addEventListener("change", applyFilters);
    firmwareFilter.addEventListener("change", applyFilters);
    searchBox.addEventListener("input", applyFilters);
    exportBtn.addEventListener("click", exportToCSV);
    clearBtn.addEventListener("click", clearFilters);

    headers.forEach((th, index) => {
        th.addEventListener("click", () => {
            const key = keyMap[index];
            sortAsc = (sortColumn === key) ? !sortAsc : true;
            sortColumn = key;
            applyFilters(); // apply filters and sort
        });
    });

    function populateFilters(nodes) {
        const roles = new Set();
        const channels = new Set();
        const hws = new Set();
        const firmwares = new Set();

        nodes.forEach(n => {
            if (n.role) roles.add(n.role);
            if (n.channel) channels.add(n.channel);
            if (n.hw_model) hws.add(n.hw_model);
            if (n.firmware) firmwares.add(n.firmware);
        });

        fillSelect(roleFilter, roles);
        fillSelect(channelFilter, channels);
        fillSelect(hwFilter, hws);
        fillSelect(firmwareFilter, firmwares);
    }

    function fillSelect(select, values) {
        [...values].sort().forEach(v => {
            const option = document.createElement("option");
            option.value = v;
            option.textContent = v;
            select.appendChild(option);
        });
    }

    function applyFilters() {
        const searchTerm = searchBox.value.trim().toLowerCase();

        let filtered = allNodes.filter(node => {
            const roleMatch = !roleFilter.value || node.role === roleFilter.value;
            const channelMatch = !channelFilter.value || node.channel === channelFilter.value;
            const hwMatch = !hwFilter.value || node.hw_model === hwFilter.value;
            const firmwareMatch = !firmwareFilter.value || node.firmware === firmwareFilter.value;

            const searchMatch = !searchTerm ||
                (node.long_name && node.long_name.toLowerCase().includes(searchTerm)) ||
                (node.short_name && node.short_name.toLowerCase().includes(searchTerm)) ||
                (node.node_id && node.node_id.toString().includes(searchTerm)) ||
                (node.id && node.id.toString().includes(searchTerm));

            return roleMatch && channelMatch && hwMatch && firmwareMatch && searchMatch;
        });

        if (sortColumn) {
            filtered = sortNodes(filtered, sortColumn, sortAsc);
        }

        renderTable(filtered);
        updateSortIcons();
    }

    function renderTable(nodes) {
        tbody.innerHTML = "";
        if (!nodes.length) {
            tbody.innerHTML = '<tr><td colspan="9" style="text-align:center; color:white;">No nodes found</td></tr>';
        } else {
            nodes.forEach(node => {
                console.log(node)
                const date = new Date(node.last_update);
                const formattedTime = date.toLocaleTimeString([], {
                  hour: "numeric", hour: "2-digit", minute: "2-digit", second: "2-digit", hour12: false
                });
                const formattedDate = `${date.getFullYear()}-` + 
                                      `${(date.getMonth() + 1).toString().padStart(2,"0")}-` +
                                      `${date.getDate().toString().padStart(2,"0")}`;
                const formattedTimestamp = `${formattedDate} ${formattedTime}`;

                const row = document.createElement("tr");
                row.innerHTML = `
                    <td>${node.short_name || "N/A"}<span class="hide-lt-md" style="color:#${ node.node_id.toString(16).slice(-6)}"> &#9673</span></td>
                    <td class="nowrap"><a href="/packet_list/${node.node_id}">${node.long_name || "N/A"}</a></td>
                    <td class="hide">${node.hw_model || "N/A"}</td>
                    <td class="hide">${node.firmware || "N/A"}</td>
                    <td class="hide-lt-md">${node.role || "N/A"}</td>
                    <td class="hide-lt-xl">${node.last_lat ? (node.last_lat / 1e7).toFixed(7) : ""}${node.last_long ? ", "+(node.last_long / 1e7).toFixed(7) : "N/A"}</td>
                    <td class="hide">${node.channel || "N/A"}</td>
                    <td><span class="hide-lt-lg">${formattedDate} </span>${formattedTime}</td>
                `;
                tbody.appendChild(row);
            });
        }
        countSpan.textContent = nodes.length;
    }

    function clearFilters() {
        roleFilter.value = "";
        channelFilter.value = "";
        hwFilter.value = "";
        firmwareFilter.value = "";
        searchBox.value = "";
        sortColumn = "short_name";
        sortAsc = true;
        renderTable(allNodes);
        updateSortIcons();
    }

    function exportToCSV() {
        const rows = [];
        const headersText = Array.from(headers).map(th => `"${th.innerText.replace(/▲|▼/g,'')}"`);
        rows.push(headersText.join(","));

        const visibleRows = tbody.querySelectorAll("tr");
        visibleRows.forEach(tr => {
            if (tr.children.length === 9) {
                const row = Array.from(tr.children).map(td => `"${td.innerText.replace(/"/g, '""')}"`);
                rows.push(row.join(","));
            }
        });

        const csvContent = "data:text/csv;charset=utf-8,\uFEFF" + rows.join("\n");
        const link = document.createElement("a");
        link.href = encodeURI(csvContent);
        const dateStr = new Date().toISOString().slice(0,10);
        link.download = `nodes_list_${dateStr}.csv`;
        link.click();
    }

    function sortNodes(nodes, key, asc) {
        return [...nodes].sort((a, b) => {
            let valA = a[key] || "";
            let valB = b[key] || "";

            if (key === "last_lat" || key === "last_pos" || key === "last_long") {
                valA = Number(valA) || 0;
                valB = Number(valB) || 0;
            }
            if (key === "last_update") {
                valA = valA ? new Date(valA).getTime() : 0;
                valB = valB ? new Date(valB).getTime() : 0;
                // reverse order for most recent first
                if (valA > valB) return asc ? -1 : 1;
                if (valA < valB) return asc ? 1 : -1;
            }

            if (valA < valB) return asc ? -1 : 1;
            if (valA > valB) return asc ? 1 : -1;
            return 0;
        });
    }

    function updateSortIcons() {
        headers.forEach((th, index) => {
            const span = th.querySelector(".sort-icon");
            if (!span) return;
            span.textContent = (keyMap[index] === sortColumn) ? (sortAsc ? "▲" : "▼") : "";
        });
    }
});
</script>
{% endblock %}
